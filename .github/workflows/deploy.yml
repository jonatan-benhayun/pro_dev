name: CI-CD BlueGreen EC2

on:
  push:
    branches: [ "main" ]

permissions:
  id-token: write
  contents: read

jobs:
  build_and_push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Sanity – Dockerfile exists
        run: |
          ls -la
          test -f Dockerfile.backend

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Sanity – IMAGE_NAME present & format
        run: |
          NAME='${{ secrets.IMAGE_NAME }}'
          test -n "$NAME" || (echo "Missing IMAGE_NAME secret" && exit 1)
          echo "$NAME" | grep -Eq '^[a-z0-9]+([._-][a-z0-9]+)*/[a-z0-9]+([._-][a-z0-9]+)*$' \
            || (echo "Bad IMAGE_NAME format: user/repo (lowercase)"; exit 1)

      - name: Build and push (backend)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile.backend
          push: true
          tags: |
            ${{ secrets.IMAGE_NAME }}:${{ github.sha }}
            ${{ secrets.IMAGE_NAME }}:latest

  deploy:
    needs: build_and_push
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - uses: actions/checkout@v4

      - name: Sanity – required secrets
        env:
          AWS_ROLE_ARN:           ${{ secrets.AWS_ROLE_ARN }}
          AWS_REGION:             ${{ secrets.AWS_REGION }}
          EC2_SECURITY_GROUP_ID:  ${{ secrets.EC2_SECURITY_GROUP_ID }}
          EC2_INSTANCE_PROFILE:   ${{ secrets.EC2_INSTANCE_PROFILE }}
          EIP_ALLOCATION_ID:      ${{ secrets.EIP_ALLOCATION_ID }}
          IMAGE_NAME:             ${{ secrets.IMAGE_NAME }}
          DOCKERHUB_USERNAME:     ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN:        ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          for v in AWS_ROLE_ARN AWS_REGION EC2_SECURITY_GROUP_ID EC2_INSTANCE_PROFILE EIP_ALLOCATION_ID IMAGE_NAME DOCKERHUB_USERNAME DOCKERHUB_TOKEN; do
            eval "val=\${$v}"
            if [ -z "$val" ]; then echo "Missing secret: $v"; exit 1; fi
          done

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Prepare user-data (inject env)
        run: |
          mkdir -p out
          {
            echo "export IMAGE_NAME=${{ secrets.IMAGE_NAME }}"
            echo "export IMAGE_TAG=${{ github.sha }}"
            echo "export APP_PORT=${{ secrets.APP_PORT != '' && secrets.APP_PORT || '8000' }}"
            echo "export DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}"
            echo "export DOCKERHUB_TOKEN=${{ secrets.DOCKERHUB_TOKEN }}"
            echo
            cat deploy/user_data.sh
          } > out/final_user_data.sh
          chmod +x out/final_user_data.sh

      - name: Launch new EC2 (Ubuntu 22.04)
        id: launch
        run: |
          AMI_ID=$(aws ec2 describe-images \
            --owners 099720109477 \
            --filters "Name=name,Values=ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*" "Name=state,Values=available" \
            --query 'Images|sort_by(@,&CreationDate)[-1].ImageId' --output text)
          echo "Using AMI: $AMI_ID"

          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id "$AMI_ID" \
            --instance-type t3.micro \
            --iam-instance-profile Name="${{ secrets.EC2_INSTANCE_PROFILE }}" \
            --security-group-ids "${{ secrets.EC2_SECURITY_GROUP_ID }}" \
            --user-data file://out/final_user_data.sh \
            --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=myapp-bluegreen},{Key=Stack,Value=myapp},{Key=Version,Value=${{ github.sha }}}]' \
            --query 'Instances[0].InstanceId' --output text)

          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_OUTPUT
          echo "New instance: $INSTANCE_ID"
          aws ec2 wait instance-status-ok --instance-ids "$INSTANCE_ID"

      - name: Get new instance public IP
        id: ip
        run: |
          IP=$(aws ec2 describe-instances --instance-ids "${{ steps.launch.outputs.INSTANCE_ID }}" \
               --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "IP=$IP" >> $GITHUB_OUTPUT
          echo "New IP: $IP"

      - name: Health check (http://IP:80/healthz)
        run: |
          set -e
          for i in {1..60}; do   # עד ~10 דקות (60*10s)
            sleep 10
            if curl -fsS --max-time 3 "http://${{ steps.ip.outputs.IP }}:80/healthz" >/dev/null; then
              echo "Health OK"
              exit 0
            fi
            echo "Attempt $i: not up yet..."
          done
          echo "Health check failed"
          exit 1

      - name: Debug: show SG rules
        if: failure()
        run: |
          aws ec2 describe-security-groups \
            --group-ids "${{ secrets.EC2_SECURITY_GROUP_ID }}" \
            --query 'SecurityGroups[0].IpPermissions' --output table

      - name: Debug: EC2 console output (last 200 lines)
        if: failure()
        run: |
          aws ec2 get-console-output --instance-id "${{ steps.launch.outputs.INSTANCE_ID }}" --latest --output text | tail -n 200

      - name: Switch Elastic IP to new instance
        run: |
          ASSOC_ID=$(aws ec2 describe-addresses --allocation-ids "${{ secrets.EIP_ALLOCATION_ID }}" --query 'Addresses[0].AssociationId' --output text)
          if [ "$ASSOC_ID" != "None" ]; then
            aws ec2 disassociate-address --association-id "$ASSOC_ID"
          fi
          aws ec2 associate-address --allocation-id "${{ secrets.EIP_ALLOCATION_ID }}" --instance-id "${{ steps.launch.outputs.INSTANCE_ID }}"
          echo "EIP associated."

      - name: Terminate old instances (keep only the new one)
        run: |
          NEW="${{ steps.launch.outputs.INSTANCE_ID }}"
          OLD=$(aws ec2 describe-instances \
            --filters "Name=tag:Stack,Values=myapp" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[?InstanceId!='${NEW}'].InstanceId" --output text)
          if [ -n "$OLD" ]; then
            aws ec2 terminate-instances --instance-ids $OLD
            echo "Terminated: $OLD"
          else
            echo "No old instances."
          fi
